#pragma once
#include "oepEntity.h"

namespace oep {
	class GameObject;  //전방 선언
	//전방 선언을 하는 이유는 각 파일들이 서로를 상호 참조하고 있는 경우 순환 참조가 발생(while의 예기치 못한 루프와 유사)하게 되는데 순환 참조가 발생하게 되면 빌드가 되지 않는 문제가 발생할 수 있다.
	//이를 방지하기 위한 방법이 전방 선언으로 이는 #include로 참조를 하는 것이 아니라 클래스의 존재를 미리 알려주는 것으로 해당 클래스를 다른 클래스에서 사용할 수 있게 된다.
	//그러나 주의해야 할 것은 클래스의 존재만 인지시킨 것이고 클래스 자체를 참조하는 것이 아니기 때문에 포인터로 밖에 선언하지 못한다는 것이다.

	//Component 클래스 - 컴포넌트들이 가지는 기본적인 정보를 가지고 있는 클래스(모든 컴포넌트는 이 클래스를 상속받아 구성될 예정. 즉, 이 클래스는 컴포넌트의 기본 골격이라고 볼 수 있다.)
	//지금까지의 작업은 게임 오브젝트라는 큰 틀에서 파생되는 여러 오브젝트들을 구성하고 동일한 특성을 가진 오브젝트들은 또 그 동일한 특성을 묶은 클래스를 만들어 이를 상속받으면서 계층 구조를 쌓아나가도록 설계가
	//되고 있었는데 이렇게 되면 오브젝트들이 증가하면서 공통된 부분을 묶은 계층이 증가해나가며 이 게임 구조가 복잡해지고 이들을 또 따로 하나씩 작업을 해주어야 하니 그 시간도 늘어나게 되는 문제점이 있었다.
	//이런 계층 구조의 문제점을 해결하기 위해 고안된 것이 바로 컴포넌트 기반 설계 즉, 컴포넌트 구조를 사용하는 것이다. 컴포넌트 구조는 상속의 계층 구조의 문제점을 보완하고자 제안된 설계 방법으로 
	//게임 오브젝트가 해야 할 일을 대신 해주는 별도의 객체를 만들어 작업을 분할하여 게임 오브젝트의 클래스 기능이 비대화되는 문제점을 해결하는 설계이다.
	//이러면 오브젝트는 각자 필요한 동작이 있으면 그 동작을 담당하는 컴포넌트를 불러와서 추가해주는 방식으로 오브젝트의 기능을 완성해나가기 때문에 오브젝트는 컴포넌트들을 관리만 해주고 실질적인 동작은 컴포넌트들이
	//해주니 오브젝트 클래스의 기능이 비대화되는 것을 막을 수 있고 하나의 동작을 여러 오브젝트에서 사용할 수 있기 때문에 재사용성도 높아서 효율적인 오브젝트 설계가 가능해진다.
	class Component : public Entity
	{
	public:
		Component();

		virtual void Initialize();
		virtual void Update();
		virtual void LateUpdate();
		virtual void Render(HDC hdc);

		void SetOwner(GameObject* owner) {
			mOwner = owner;
		}

		GameObject* GetOwner() {
			return mOwner;
		}

		~Component();

	private:
		//컴포넌트가 추가된 게임 오브젝트를 알아야 해당 오브젝트에만 동작을 하니 어떤 오브젝트에 추가된 것인지 저장을 해 줄 변수 추가
		GameObject* mOwner;
	};
}
